なぜ環境変数を使う？
->PCごとの環境に左右されないため
・家と学校のPCではDxLibのパスが違うから毎回設定を変える必要がある


パス
1exeやその他ファイルが置かれているフォルダ
	C:¥DxLib
2フォルダを含めたファイル名
	C:\DxLib\DxLib.h
★絶対パスと相対パスの違い
1絶対パス(フルパス)
	C:\DxLib\ライブラリに必要なファイル名\DxLib
2相対パス
	cppフォルダに main.cppというファイルがある
	->cpp/main.cpp となる
(../main.cpp　../は一つ上のフォルダを示す)

環境変数として
DXLIB_DIR : C:\DxLib_VC_3.24b\プロジェクトに追加すべきファイル_VC用

環境変数の元の文字列を取得する方法
1コマンドライン->%で囲む
2visualstudio->$()で囲む

VisualStudioのデフォルトの環境変数が設定されている

プロジェクトファイル(vcxprojファイル)があるフォルダ
->$(ProjectDir)
===>これを使うメリットとして、チーム制作や別のPCで作業をするときにPCによってvcxjrojが置かれている
	ファイルのパスが違っても同じように動作することができるようになる

exeを出力するフォルダ
->$(OutDir)		で見れる

場所の確認方法
プロパティ->C/C++->全般の 追加のインクルードディレクトリ をクリックして右の三角を押した先に
$(ProjectDir)など書くと 評価された値 にフルパスが表示される

今回作るアプリの設定
1パスの設定
・C/C++->全般 の 追加のインクルードディレクトリ 
	$(DXLIB_DIR)を書く
・リンカー -> 全般 -> 追加のライブラリディレクトリ
	$(DXLIB_DIR)を書く
・サブシステムの設定
	OSがどのモードでアプリを起動するか
	1コンソールアプリとしてか、コマンドプロンプトとしてか
	2Windowsアプリ->Windowから起動
コンソール(CONSOLE)　main関数を呼ぶ
Windows(WINDOWS)　WinMain関数を呼ぶ
		のどっちかをサブシステムとして設定する

なんでめんどいシステムになっているか
・直接いじろうとすると死ぬほどややこしい
・アプリが確保しているメモリは「仮想メモリ」という
OSが領域を探し、使いやすいように変換して渡している

物理メモリを直接いじるのは面倒なので
OSが仲介して翻訳(楽に)してくれている

★リンカーエラーについて
・4パターンの原因
1.サブシステムをとメイン関数の違い
	CONSOLE->main関数
	WINDOWS->WinMain関数
2.必要なライブラリの指定ができていない
	「リンカー」 -> ライブラリ -> 追加のライブラリ指定が違う
	ライブラリの指定がそもそもできていない
	#pragma comment(ライブラリ名 ,lib)
	プロジェクトプロパティ->リンカー->追加のライブラリに
	libファイルを置く
3.なぜか必要なcppファイルがプロジェクトに含まれていない

4.使っている関数の実装がない

★コンパイルとリンク
	コンパイル: ●●.cpp -> ●●.objに変換すること
	リンク:  ●●.objや××.objや■■.libなどを一つにまとめてexeにすること

ヘッダー:関数の名前と引数の型のカタログのみを置いている
obj/lib:関数の本体が記述されている

プログラムの注意点
・Warningがあっても動くができるだけなくすこと
・MainやWinMainも関数のため戻り値(return)が必要
	0:正常終了　-1:異常終了

対処のしづらさランキング
1.実行はできるし、クラッシュもしない。
2.ある程度実行して動作するけど、ある時クラッシュする。
3.リンカエラー
4.コンパイルエラー

1についてはプロでも悩みの種
->間違っているときは人為的にでもクラッシュさせよう(Debugの時)
Releaseの時はクラッシュさせないように

そのためには assert関数を使う
クラッシュした時に「中止」をおさないで
「再試行」を押す

中止するとプログラムの実行自体が終了してしまい状況がわからなくなる
再試行すると、クラッシュの時点でブレークされて状況確認ができる
無視はだめ


assertという関数
#include <cassert>　で使えるようになる

assert(条件式);
この条件式の中身が偽(false)のとき人為的にクラッシュする
->バグの原因の早期発見ができる

バグではないが、「明らかに間違っている状況」に対して
クラッシュを起こすために使う


配列
int a[10];

こんとき
a[7] = 7[a] = *(a + 7)　です
配列の名前というのは配列のメモリのアドレスを入れた変数
		つまりポインタと同じ役割です

ここで注意点
ここでいう +7 は7バイトのことではない
コンパイルされた時点でaがint(4バイトとわかっているので)
+7 -> 7 * 4 -> 28に変換される
	果7番目の要素を返している

ついでに2次元配列について
2次元配列は1次元配列です

どういうこと？
ー＞2次元配列でもメモリが1次元的に連続しているため
例えば、	a[n][m]　というのを
	a[0][m*col+n]　　という風に指定できます
