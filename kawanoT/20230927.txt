型とメモリの関係
	自分たちの解釈する数値と、メモリ上に書いてある値は必ず一致するわけではない
型には2つの意味
  ①「メモリ上の値をどう解釈するか」
    ②「その型そのものがどのくらいメモリをつぶすか」

人はメモリ上にあるデータをそのまま使うことはできない
->データおよび「解釈(ビュー)」とセットでやっと使い物になる

「参照」について
　ポインタみたいなもの->指し示しているのはアドレス
　ただし、ポインタより使いやすい
　普通に*や->をつけなくても、普通の「値変数」と同じように使える

int b = 12;
int & a = b;
->aはbと同じ場所を参照するため
　b++するとa++され、a++するとb++される

参照のルール(ポインタと同じ役割だがポインタよりルールが厳しい)
　①宣言時にどこを参照するか決まってないとダメ
	(コンストラクタの初期化リストは許される)
	int& a;	//ダメ
　②参照先の変更不可
	int& a = b;
	a = c;	//これはcの値をaにコピーしているだけ

参照をポインタどっちを使う？
★参照のほうが良い場面
　①初期化時に参照っ先のアドレスが確定している場合
　②参照先を最後まで変更しないことが確定している場合

union(共用体)について
　共用体とは、要素それぞれが同じメモリを共有して使う型
　よく目にする型ではないが、古いコードなどではよく見る(メモリをけちるため)

C++的な「型」について
　std::vector<std::string>これも1つの「型」
　クラスと同じような扱いになる

　型と値のコピーについて
　　通常、同じ型同士の=演算は値のコピーが行われる
    値のコピーはメモリの内容をそのまま相手にコピーする


	int a[4] = { 1,2,3,4 };
	int b[4];

	b = a;		//なぜダメか

	これはa(配列の先頭アドレス)をbにコピーしようとしている
	->アドレスの値をコピーしようとしている

	+配列は宣言した時点でアドレスが固定される(アドレス自体がconst)
	constの値を変更しようとしているためエラー

	int* c = a;	//ok

vectorについて
	std::vector<int>a = {1,2,3,4,5};
	std::vector<int>b;
	b = a;
配列とは違い、これはちゃんとコピーされる
→構造体のような動きをする
　(vectorの中で定義されている=演算子オーバーロードがコピーしてくれる)

C++の中にはSTLというのがある
この中でよく使用する型として
std::vector<T>
std::map<Key,Value>	がある。

std::vector<T>は動的配列を意味する
動的配列とは、固定長の配列と違い後から配列のサイズを変更できるもの

Tと書いた部分に、動的配列の要素の型をいれることで
T型の、動的配列を作ることができる

std::vector<int>	int型の配列
std::vector<float>	float型の配列

int a[4];	//静的配列
a = {1,2,3,4,5};	//ダメ

std::vector<int> b = {1,2,3,4};	//動的配列
b.push_back(5);	//後から追加できるがメモリの場所に注意
b = {1,2,3,4,5} //ok

なぜ動的配列が必要なのか
通常の配列は配列の要素数が最初から決まっているときした使えない

ゲーム開始時点では、ステージの広さがわからない
ステージデータをロードして初めてステージの広さがわかる
そんな時、マップデータを後から拡張する必要がある
→固定配列では不可能だが、動的配列なら可能

★ゲーム用のTips
・関数に「配列や構造体やvector」を渡す際は、できるだけ参照渡しにしよう
→引数で渡すとき、意味合い的には
　引数の型 変数名 = 引数;
	と書いているのと同じ。int や floatならせいぜい4Byteなので
	このコストはそんなに大きくない

　ところが構造体の場合はたいてい16Byteや、32Byteとか
　なんなら512Byteや、もっと言うと何KBになったりする。
	何がダメ？？
	　　↓
　関数を呼び出すたびに構造体のサイズ分のメモリが確保されてしまい
　さらにメモリのコピーが発生する。1～2回なら問題ないが、
　3D座標の受け渡しなどは、ループ内で10000回とか発生する
　そうなると、512Byteのコピーは5120000Byteのコピーコストになる

アプリの処理の重さに影響を与える順番で行くと
ロード>>メモリの確保・解放＝メモリの内容をコピー>それ以外の演算

→★★原則、関数に構造体(8Byteを超える内容のもの)は参照渡しにしよう
　　ただし、ただの参照渡しだと副作用があるため関数内部で引数の値を
		書き換えられないようにconst参照で渡そう

C++では「保証する」という考え方が大切で、
そのために参照引数をconstにしたり、関数のお尻にconstをつけたりする
→参照引数は、内部で書き換えられないことを保証し、
　const関数は、メンバ関数内部でメンバ変数の内容を書き換えられないことを保証する

autoについて...C#のvarみたいなもの
　普通、変数を宣言するときには、int や floatなど指定する
　もし、右辺値から「型」を推測可能な場合には、int や floatではなく
　autoと書けば型をコンパイラが推測して自動でint や floatにしてくれる
　このことから、autoを使うと、右辺値の型さえ確定していれば全部autoでok
　なんでautoみたいなのがあるかというと、プレグラムを書いてるうちに
　「あ、これfloatのほうがいいな。全部変えよう」みたいなとき
　変更箇所が多く、ミス(バグ)が起こりやすくなる
　なので、型自体を右辺値に決めさせようという思想の中から生まれました

★autoの注意点
・思った型になっていないこともあるので、変数にカーソルを合わせて確認しよう
・autoといっても、型はコンパイル時確定されるので
 auto a = 5;
 a = 3.14f;
 としても、aはint型のため、 a = 3となる

 autoは&などを引き継がないため、参照として扱いたい場合は
 auto& a = b;
 　とする。例えば
 int c = 3;
 auto& b = c;	//bはcへの参照になる
 auto a = b;	//aはただのbのコピーになる
 この場合、bの値をいじるとcも変わるが、aはただのコピーのためaは変わらない
 
 よくあるのが
 for(auto e : arrat){
   e++;
 }
 この場合、もとになった配列は書き換えられない。
autoを使ってほしい部分
①後で型の名前が変わりそうなとき
②型の名前がやたら長いとき
③型がやたらとややこしいとき←関数ポインタなど
　　関数ポインタは宣言がvoid(*f)(引数)みたいにややこしいので
　　auto使ったほうが見栄えもいい

charとwchar_tは明確に違う
プロジェクト→プロパティ→全般→文字セット
マルチバイト→char*がデフォルト文字列を表す
unicode→wchar_t*がデフォルト文字を表す

①　LoadGraph("●●.png")
②　LoadGraph(L"●●.png")

文字列は通常文字とワイド文字がある
通常の文字リテラル　char*で表せる  ""でおｋ
ワイド文字リテラル　wchar_t*で表せる　L""のようにLが必要


















　std::vector<T>が1つの型

