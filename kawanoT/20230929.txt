STL(Standard Templete Library)
C++でTempleteは、型をいったん決めずに
関数やクラスを作っていおいて利用時にその型を決定するもの

temlate <typename T>
T add(T a,T b);

のように書くと「テンプレート関数」となり
呼び出しがかかれるまで型が確定しない
呼び出しが書かれた時点で、その型のadd関数が生成される

temlate <typename T>
class Pointer{
	private:
	    T* pttr_;
};

のようにクラスのメンバ変数の型がクラス利用する場面を書くまで確定しない「テンプレート関数」

このテンプレートの性質を利用して様々な便利なクラスや科数を提供してくれるのがSTL
代表的なものがvectorで、動的配列を表す
->動的配列とは？

int a[10];
	は固定配列であるため、11個目を確保したくてもできない
実は固定配列は安全そうに見えてそんなに安全ではない
固定配列というのはプログラムを書いた時点で配列の大きさが決まっていないと使えないもの
→マップデータ(ステージのサイズが決まっていない)
→ポリゴンデータ(頂点の数が読むまで分からん)　などには向いていない

そんな時に使えるのが「動的配列」
利用方法はいろいろあるがもっとも簡単に使えるのがvector

int a[10];	はOKだけど
int  a[rand()];	はダメ
実行時までわからないから確保できない

たいしてvectorは
vector<int> a(10);　これで10個確保できるし
vector<int>  a(rand()); でもOK

また、後からサイズを変更できる
a.resize(remainEnemies);

なんだったらお知りに一つだけ追加もできる
a.push_bacl(要素);
という風に書くこともできる

もちろん普通に配列のようにも使える
vector<int> a = {1,2,3,4,5};
みたいに最初から決まっている数字を初期化することもできる

お仲間にmap,list.arrayなどがある
map : 連想配列
map<stirng,int> animals;
animals["dog"] = 3;
animals["cat"] = 5;
animals["rabbit"] = 7;

array : 固定配列
通常の配列よりもセキュリティ面で優れている
array<int,4> a;
これはint4つ分の固定配列
意味的にはint b[4]と同じ　　しかし…
b[rand()]; は実行時エラーを起こしませんが
a[rand()]; はは煮貝になるとクラッシュをする(事故現場がわかりやすい)

arrayでもmapでもvectorでも共通して便利な関数が使える
・size();　=>要素数を得られる
・data();(vectorとarray)　=>配列のメモリアドレスを返す

listについて　(難しいため、理解できなかったらいったん忘れてもよい)

vectorと同じ働きをするが、内部的なデータの持ち方が異なる
★vectorはデータがメモリ上で連続しており
　listはデータがメモリ上でばらばらである。

このことからvectorはデータの検索が早くメモリをファイルに保存するときなどに便利
ただし、要素の追加と削除が遅い。

それに対してlistは、メモリ上の連続性は問わないため要素の追加や削除のコストは安いが
データの検索はvectorより遅い。
また、メモリ上でバラバラなのでセーブデータとして使うには不向き

初心者は迷ったらvectorをつかっとけ


stringの正体について
stringはC++において文字列を表すもの
STLの仲間
Cでいうと文字列はchar*ですが
それよりもかなり便利場機能をたくさん持っている

stringの関数
= : 代入
+,+= : 文字列の連結
==,!= : 比較
length() : 長さを測る
find(文字) : 文字列中の文字の場所を返す
rfind(文字) :  文字列中の文字の場所を逆(後ろから)返す
substr(idx,[len]) : 文字列の一部を返す
c_str() : C言語の文字列として返す
	DrawFormatString(x,y,色,"%s", str.c_str());
	なんていう使い方をする

stringの本当の姿
string ≒ std::vector<char>
char型の動的配列に便利な関数を足しただけのもの
string str = "HelloWorld";
str[5] == 'W';
str.size() == str.length();
str.data() = 先頭アドレス
★str.resize(n)で文字列のサイズを変更
　場合によっては関数から文字列データを受け取る際
　中身がカラであってもメモリを確保する必要がある(ファイルロードやWin関数)
　そういったときにresizeを使う

文字列(文字)について
歴史
昔は日本語を使えなかった。
この時代の文字セットをASCII文字列といい、
0~127の7bitで文字が表現されていた。
この時代でも8bit使って、カタカナなどは使えていた
 　→半角カナ(半角ひらがながない原因)
きちんと日本語を使うために「マルチバイト」表現というのが出てきた
日本語 : SJIS(Windows),EUC-jp(Mac?)
これは、記号、英語、半角カナは1バイト、それ以外は2バイト以上で表現するものだった

そのあとに「Unicode」というのが出てきた
ばらばらだったものを統一しよう　となった
このUnicode、統一されているはずだが、実は
UTF-8,UTF-16,UTF32などある
VisualC++ : デフォルト　UTF - 8
C# : デフォルト UTF - 16
UTF32 : Androidとか








