おさらい
①Cppにおけるテンプレート
②STLについて
  Vector<T> : 要素の型がTの可変長配列
③stringについて
　vector<char>を改良したもの
④C/C++の「文字列型」にはマルチバイト型とワイド文字の二つがある
　　マルチバイト:shift-JIS(SJIS)
　　ワイド:Unicode(UTF-8)
プロジェクトの設定を「Unicode」にしていてもcppのテキストファイルの
しようそのものはSJISになっている
マルチバイト:char*,string
ワイド:wchar_t*,wstring
これら相互の変換をするにはWindows関数を使う必要がある

MultiByteToWidwCharという関数を使う
→ややこしいのは２回呼ぶ必要がある
この処理はゲーム制作の中でも何度か使うので
自分の標準関数として作りましょう
自分のプロジェクトにStringUtilityというクラスを作って
static関数ばかりのクラスはnewの度する必要がない　そういうクラスを作る

クラスのpublicメンバ関数には「必ず」コメントをつけましょう
publicメンバ関数を使うのは利用者側(自分ではない人が使う)
コメントはヘッダ側に書こう(///でかく)

MicrosoftのAPIのマニュアルの読み方
int MultiByteToWideChar(
  [in]            UINT                              CodePage,
  [in]            DWORD                             dwFlags,
  [in]            _In_NLS_string_(cbMultiByte)LPCCH lpMultiByteStr,
  [in]            int                               cbMultiByte,
  [out, optional] LPWSTR                            lpWideCharStr,
  [in]            int                               cchWideChar
);

[in]と書かれていたら普通のパラメータ(値が書き換えられない)
[out]と書かれていたらポインタを渡して書き換えられることを期待します
[optional]は、この引数がなくてもいいよ(nullptrや0でも動作する)を表す
UINT = unsigned int
DWORD = uint32_t = 4　バイト符号なし整数型のこと
LPCCH = LPはポインタのこと、CCH=(const char型)→const char*を入れろ
LPWSTR = WSTRはワイド文字の事、それのポインタを入れろ


いきなりこれを見て理解できるかというと難しいと思うので、
理解できなくても構わないが、とにかくマイクロソフトのマニュアルを見る癖をつけておく

DxLibに文字列を渡す際は、たいていの場合はchar*やwchar_t*もしくはTCHAR*などのように
文字列のアドレスを渡さなければなりません。なので、たとえば、
wstring wstr = "HelloWorld";
DrawString(x,y,wstr,0xfffffff);	//これはダメ。型が違う(wstring≠wchar_t*)
string::c_str()
wstring::c_str()
これらの関数は、stringやwstringをC言語の文字列に変換する

オブジェクト指向の三大要素
①カプセル化
②継承
③ポリモーフィズム

なぜカプセル化するか
　①クラス内部の安全性を高めるため
　②利用者側に対しての負担を減らしている
　　　公開情報を限定的にして利用しやすくしている
	(利用者にとって不要な情報を見せない)

クラスと構造体の違いはデフォルトがprivateかpublicかだけである
class -> private
struct -> public

継承→親子関係
　子は親の特徴を受け継いでいる
　子は親とis-aの関係である
　子は親のpublicとprotectedにアクセスできる
　親にpublicで実装されているメンバ関数は子で実装しなくても
　　子の関数として呼び出せる
　
親子関係の時にだけ意味を持つカプセル化属性として「protected」というのがある
これは、自分の子クラスには公開しますよ、というメンバに対して指定する

ポリモーフィズム(多態性)
継承はis-aの関係であるということを離したが、
犬も「動物」
猫も「動物」
ウサギも「動物」
というように全部「動物」といえる
ポリモーフィズムでは全部「動物」として扱おう　　という仕組み

継承の考え方は、下に向かってどんどん派生していくという考えだったが、
ポリモーフィズムの考え方は逆に上に向かってどんどん抽象化(汎化)して行くという考え方

何の役に立つの？
→利用者側の処理を分けなくて済む

このポリモーフィズムにつきものなのが、virtual指定子で、
親の関数の先頭につけることで、親の関数ではなく子の関数が呼ばれる

virtual void Attack()
{
	cout << "未定義" << endl;
};

or

virtual void Attack() = 0;



ポリモーフィズムとは、一言でいうと、より抽象的な概念をまとめて扱えるようにする仕組み
　それをするには、親の関数にvirtualをつけることで、実際の動作は子に委託することができる

  virtual void Attack() = 0;
　という風に書くことで自分は実装しない”ということを約束できる
　子の関数を「純粋仮想関数」という。
　　ただし、純粋仮想関数を持つクラスは単体では存在できません
　　継承して、「子」としてオブジェクト化しないと存在できない
　　また、純粋仮想関数は「子で必ず実装しないといけない」
		という制約が生まれる

ポリモーフィズムは三大要素の中でもややこしいが、
いわゆるデザインパターンなどは、ポリモーフィズム前提で作られており、
利用法多岐に渡る

C++ではnewで動的配列を確保することもできるが、解放がややこしい
int* a = new int[n];
で、動的配列を作れるが、これを解放するときは
delete[] a;
と書く必要がある。
ややこしいため、この授業では動的配列はすべてvectorを使う
vector<int> a;
の場合、deleteしなくてもclear()するだけでメモリが解放されるし
スコープを抜けた時点で自動的に解放される


















