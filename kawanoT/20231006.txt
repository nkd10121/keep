コメントの書き方
　原則として「意図」をかくようにする
　「なんでそのコードを書いたか」がわかるように

×　i++;	//iをインクリメント
○　i++;　//配列のインデックスを順次巡回するため

★コメントにうそを書かないようにしよう(途中の仕様変更などによって後から嘘にあることがある)
    →プログラムをアップデートしたら、コメントも見直そう

基本的にコメントの書き方は自由だが、クラス宣言側のpublic関数だけは「必ず」コメントを入れよう
	→public関数はほかの人も利用する可能性があるため

関数の上で「///」と打つと関数説明のテンプレート的なのが出てくるため
それに従ってコメントを書こう

きほんてきにWindowsのAPIに関しては、最終的にはMicrosoft公式の
リファレンスを読もう。むずくて意味が分からなくてもいいから、
一回は目を通しておこう。そのうち慣れる

わかりやすい説明をしているサイトも多いが、場合によっては嘘の可能性がある


標準の特殊な方の書き方
基本的には数字がビット数を表していると思っていい
先頭にｕがついているものは符号なし(unsigned)を表している

unit32_t : 32bit符号なし整数型
int32_t : 32bit符号あり整数型
unit16_t : 16bit符号なし整数型
int16_t : 16bit符号あり整数型
unit8_t : 8bit符号なし整数型
int8_t : 8bit符号あり整数型
byte : 8bit符号なし整数型

★今日やること
Applicationシングルトンクラスを作る
時間があれば、stateパターンによるシーン遷移を作る

シングルトン(Singleton)クラスとは何
　アプリケーション中で一つしかインスタンスがないことを保証するクラス
　どこからでもこのインスタンスにアクセスできる
　シングルトンクラスとは「お行儀のよいグローバルオブジェクト」である。

インスタンス : メモリを確保して作った実体(メモリを食ってる)
static関数 : そのクラスの実体がなくても呼べる関数
ローカルstatic関数 : 普通はローカル変数は関数を抜けるとともに
	解放されるが、static関数は削除されない
	アプリケーションが終わるまで存在し続ける

シングルトンクラスの作り方
　コンストラクタをprivateに書くことで、オブジェクトを動的に生成できないようにする
　Application app;//×
　Application app = new Application;//×
　Application& app = Application::GetInstance();//OK

　Application app = Application::GetInstance();//通るが×
	これは別のアドレスにコピーができちゃってる
　コピーコンストラクタというのが悪さをしている
　クラスを作ると
　①暗黙のコンストラクタ＆デストラクタが生成されている
　②暗黙のコピーコンストラクタも生成されている

普通のコンストラクタ
クラス名();

コピーコンストラクタ
クラス名(const クラス名&)

演算子オーバーロード
=+-*/などを再定義する
戻り値 operator演算子(右辺値);

今回のように、オブジェクトからオブジェクトへの代入を禁止したいなら、
void operator(const クラス名&);
	をprivateに置くようにする

もっと徹底するならそもそも使えなくする
クラス名(const クラス名&) = delete;
void operator(const クラス名&) = delete;

シーン遷移について
　タイトル画面→ゲーム画面→ゲームオーバー→タイトル画面
　というように場面によって表示も入力に対する応答も変わる
　この一つ一つの場面のことをシーンという

　今回は３つのシーン「タイトル」「ゲーム中」「ゲームオーバー」を切り替えられるようにする
　「stateパターン」というテクニックを使う
　ポリモーフィズムを利用して、「現在のシーン」を次から次へ切り替えて遷移する
　このパターンではそれぞれのシーンが次のシーンでの切り替えを制御する

初期化リスト(初期化子)
　クラスのメンバ半数の初期化は基本的にコンストラクタ内で行いますが、
　複雑でない変数の初期化であれば

クラス名::クラス名(引数) : メンバ変数(初期化値){
}

のようにして初期化できる。
C++のしようとして、この方法で初期化することが推奨されている
また、メンバ変数が参照や、constの場合はここで初期化せざるを得ない

固定配列もなるべくSTLを使おう
char keyState[256];
これもSTLを使うと
std::arrat<char, 256> keyState;

それぞれのシーンを状態とみなして切り替えるという書き方をした
SceneManagerに「現在実行中のシーン」を指し示すポインタを持たせて
それを書くシーンが切り替えられるようにした

SceneManagerはUpdateとDrawをもっていてそれぞれ実行中のシーンの
UpdateとDrawを呼び出している

どういう条件でどのシーンに遷移するかは各シーンが知っているため、
Managerは現在実行中のシーンがどのシーンかしらなくていいし、どのシーンに遷移するかは知らなくていい

この方法がポリモーフィズムを利用したパターン

生ポインタを使ったがたまに解放し忘れが発生する
これを防ぐ仕組みとして「スマートポインタ」というのがある
つぎはこれに変更して安全に実行できるようにする





















