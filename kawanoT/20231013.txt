ポリモーフィズム
継承したクラス群を親クラスとみなすことができる

Scene <|-- TitleScene
Scene <|-- PlayingScene
Scene <|-- GameOverScene

状態遷移 : とある状態から、次の状態へ、特定の条件で遷移する
この状態と、繊維条件を特定のクラスだけで管理するのは
少し大変なので、それぞれの状態クラス自身に遷移をコントロールさせる

初期化リスト(初期化リスト)というのがある

コンストラクタ(パラメータ) : メンバ変数1(値),メンバ変数2(値)
と書くことでそれぞれのメンバ変数を初期化することができる
この部分での初期化はメンバ変数のアドレス確定と同時とみなされる
ため、const変数や、&参照などの初期化につかわれる

ここでの注意点は親クラスのconst変数や、&参照のメンバの初期化を
子クラスで直接行うことはできない
→なので、初期化リストでは親クラスの引数付きコンストラクタを呼び出すことで
constや&参照の中身を決定する
子クラスコンストラクタ() : 親クラスコンストラクタ(引数)

シングルトンクラス(Singleton)
アプリケーション内にそのクラスのインスタンスが1つしかないというクラス
補償すべきことはそのクラスが1つしかないということ
(これを保証できないならシングルトンとは言えない)
言い換えると「お行儀のよいグローバル変数」

作り方:コンストラクタをprivateにする
これによって、他人がそのインスタンスを生成することができなくなる
それだけでは利用できなくなってしまうだけなので、インスタンスを
作成しそこにアクセスできるようにする

static変数、static関数とは
宣言した時点で、アドレスが確定しているもの
なので、staticメンバ関数はクラスオブジェクトが生成されていなくても
呼び出すことができるし、static変数は宣言した時点でアドレスが確定するため
スコープを抜けても、その場に居続け、何度参照しても同じアドレスを見ている()

今回、Applicacion::GetInstance関数でstaticオブジェクトへの参照を取得するようにしている
注意点として「参照」でないといけない

呼び出し側も
auto& app = Applicacion::GetInstance();
のように参照型で受け取らないといけない

Application applicacion = Applicacion::GetInstance();はダメ！！！！

①、Applicacion::GetInstance()関数内のstatic変数
②、Applicacion applicacion　の時点で、別の場所にメモリが確保され
そこにApplicacionの実体が生成されている

なのでApplication applicacion = Applicacion::GetInstance();
を許してはいけない

ところが実は見えない部分に「コピーコンストラクタ」という関数ができていて、
そいつが勝手にpublic側に置かれているため、特に対処しなければ
このコードは通ってしまう

なので、これを防止するためにApplicacionクラス側では明示的に
コピーコンストラクタを宣言して、これをprivateに置く
もっと徹底するなら、代入演算子オーバーロードもprivateに置く
さらに徹底するならこれの後ろに=deleteをつけて絶対に呼べないようにする

コピーコンストラクタはこのような宣言になる
クラス名(const クラス名& ref)

これを禁止する
private:
     クラス名(const クラス名&) = delete;
これでもう、GetInstance関数

usingについて
いろいろ使い方が多岐にわたるので、覚えるのが大変だが
ひとまず覚えておいてほしいのが「別名の定義」

std::map<std::string,std::vector<Monster*>> monsterTable;
といちいち書くのが面倒だしパッと見わかりずらい。
こういうときにusingで別名を作る

using MonsterTable_t = std::map<std::string,std::vector<Monster*>>;
と書くと、

MonsterTable_t monsterTable;
と省略することができる(長文を複数書かなきゃいけないときなど)

メンバ関数ポインタの時も使える
class Monster
{
   void (Monster::*UpdateFunc_)(Input& input);
};
これはUpdateFunc_がメンバ変数に当たるのだがわかりにくい
そこで

class Monster
{
   using UpdateFunc_t = void void (Monster::*)(Input& input);
   UpdateFunc_t updateFunc_;
};

そういうわけでusingは可読性を上げるためにも結構使う

あとはusingがよく使われるのは
using namespace std;
のように「今から書く関数の先頭にはstd::つけるかも」
というルールを作ったりする

★「using namespaceはヘッダでは書かないで」
using namespaceの影響範囲は、using namespaceより下の
すべての行であるため

#include"~~.h"というのは
~~.hの内容をそのままコピーしているだけのため、
下手にヘッダ側でusing namespaceをおこなうと、想定外の範囲におよんで把握できなくなってしまう
cpp側だけでやるようにしよう。
(クラス内でのusing namespaceはOK)

::はスコープ解決演算子と言って、名前空間やメンバ変数などを
明示的に示すために使う

namespace myprog
{
   class Player
   {
      public::
	static Func();	
   }
}


このなかのFuncを呼びだしたかったら
myprog::Player::Func();	のように呼び出す

シーン中の状態遷移(状態遷移の中の状態遷移)
メンバ関数ポインタによる状態遷移をやってみよう

メンバ関数ポインタとは
メンバ関数を指し示せるようなポインタ
★関数も実はアドレスを持っている。で、関数ぽんたは
　そのアドレスを格納している変数
そのアドレスを「呼び出す」ということをすれば、関数が実行される
実は関数というのは、特定のアドレスにジャンプすることを
示している。そのアドレスを書くのするポインタを切り替えていくことで
実行される関数を切り替えることができる

用は今の更新関数を切り替えることで様々な状態を維持したり
切り替えたりできる

ただし、メンバ関数ポインタは文法がややこしい
①まず宣言:戻り値 (クラス名::*ポインタ変数名)(引数);
②次に代入:ポインタ変数 = &クラス名::状態関数名 
③実行:(this->*ポインタ変数)(引数);

状態遷移にはいくつか方法があり
①stateパターンで、現在実行中のクラスを切り替える
②メンバ関数ポインタで、現在実行中の関数を切り替える
③これらでうまくいかないときはswitch文でも何でも使おう

4つのキャストについて
static_cast<型名>(元の変数):普通のキャスト
dynamic_cast<型名>(元の変数):ポリモーフィズムを使っているときに適切な子クラスの型に変換する
		変換できない場合はnullptrを返す

static_castは、特にnullptrを返さずに変換できる
	→バグの元
dynamic_castはアウトの時にnullptrを返すため変換できない場合はすぐにわかる
















































