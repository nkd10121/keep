デザインパターン
①シングルトンパターン
　(一人っ子パターン)
　→そのアプリケーションの中で「実体」が1つしかないということを
　　保証するクラス
　　「実体がある」ということは、そのオブジェクトのためにメモリを消費している
	そのクラスのsizeof()分だけメモリが使われる
　　実体 = インスタンスともいう

　　「型(structとかclassとか)」と「実体」は違う
　　型は単なるプログラム言語上の約束事なので、「概念」みたいなもの
　　概念は、メモリを消費しない。これがメモリを消費して変数なりなんなりに
　　割り当てられたときに「実体化」する
　　
　　int;	  //メモリを消費していない(実体がない)

　　int a;//sizeof(int)だけメモリを確保して、それを変数aとして使う
　　　　　//実体化している

       int* p;   //これはメモリはsizeof(int*)だけ消費している
　　　　　　//ただしintの実体ではなくintの実体のアドレスを格納できる変数を
	　   //宣言し、アドレス格納体の実体がある状態

　　int* p = new int;  //これはどこかのアドレスにsizeof(int)を確保して
		　　  //そのアドレスにpを代入している		
		     //<-int の実体がある

　で、シングルトンクラスの実体は、アプリケーションで一つなので
　異なるメモリアドレスに二つ存在してはならない
　要は、このクラスを使用するとどこから使っても同じ実体を指し示す

　そのためには
　①使用者側にnewをさせない
　②使用者側に参照やポインタ以外で宣言させない
	が必要になる

　シングルトンクラスはこのためにコンストラクタをprivateにして
　「外部からコンストラクタを呼び出せなくする」
　　クラスはメモリ自身のメモリを確保するときに自動でコンストラクタを呼ぶ
　　class T;
　　T t;//メモリ確保
　　T* t = new T; //メモリ確保

　子のメモリ確保というのは、どちらもコンストラクタを呼び出す
　C++ではクラスを宣言やnewで実体化しようとする場合は
　 T* t = (T*)malloc(sizeof(T));
　★mallocというのはC言語の命令で単純にメモリを確保してアドレスを返すだけの関数
　要は、確保した後に内部で(見えないところで)クラス名と同じ関数
　つまりコンストラクタをコールしている
　T t;
　→　malloc(sizeof(T));
　　　t.T(); //コンストラクタを関数として読んでいる
　※こうは書いたが実はコンストラクタの呼び出し時とメモリ確保は同時に行われると思っていい
　　なのでコンストラクタを封じられていると、呼び出し側はＴの型を
　　確保することができない

　これを利用する。つまり、コンストラクタをprivateにすると
　使用者側では変数の宣言もnewもできない
　ただし、privateでも自分自身だけはコンストラクタを利用できるため
　この性質を利用して
　①コンストラクタはprivate
　②staticインスタンスを返す関数はpublic
　にして、外側からは②の関数を通してしかそのクラスの実体にアクセスできないようにする

　static変数とstatic関数について
　staticは静的という意味でメモリを確保したらそこにい続ける

　static変数 :
　ローカル変数だろうが何だろうが同じアドレスを見続けて
　スコープ外に出ても、メモリの内容を覚えている
　ローカルstatic変数はその変数のアドレスが同一なので
　どこからアクセスしても同じものといえる←シングルトンの制約に
　ちょうどいい性質
　
　staticメンバ関数 :
　通常のメンバ関数はクラスが実体化するまでは呼び出せない
　が、staticメンバ関数は実行時にすでにアドレスが確定しているため
　実体化されていなくても呼び出せる
　
　class c{
　　public:
　　　void FuncA();
　　　static void FuncB();
　}
　
　FuncAはCが実体化しない限りアドレスが確定しないので呼び出せない
　C::FuncA();//どこにあるかわからない　×
　C::FuncB();//呼び出せる

　なお、通常のメンバ変数の呼び出しは
　C c;
　c.FuncA();
　c.FuncB();
　のように使うが、これは左側が変数なのでこういう風に見える
　C.FuncB();とは文法上書けない
　「.」はそのアドレスから見たメンバの場所を参照する演算子だから
　この場合はスコープ解決演算子である::を使用して呼び出す
　C::FuncB(); という書き方

　class Singleton{
　　　private:
          //このコンストラクタをprivateに入れることで勝手に実体化されるのを防ぐ
	　Singleton();
      public:
	  static Singleton& GetInstance(){
		static Singleton instance;//
		return instance;
	}
　};
　こいつを使うには
　Singleton& single = Singleton::GetInstance();
　のようにして使う。このインスタンスは必ず一つのみであることが保証される？
　このままだと
　Singleton single = Singleton::GetInstance();
　が通ってしまう。なぜかというと、
　実はこれは通常のコンストラクタではなくコピーインストラクタが
　呼ばれているため、コピーのほうはpublic扱いになっている
　通常は、デフォルトコンストラクタ、デストラクタ、コピーコンストラクタ、代入に
　関してはプログラムが勝手に内部でpublicとして作ってしまっている

　「コピーコンストラクタ」というのは、宣言時に右辺値にほかの
　実体を配置することで、右辺値と内容が同じものを新たに作る際に
　呼び出されるコンストラクタである
　なので、上の例では、GetInstance()で得られた実体を元に
　新たな実体を作っているということになる
　なので、これも禁じる必要がある

　コピーコンストラクタの宣言は
　クラス名(const　クラス名&);
　となるので、これをprivateに配置することで
　コピーとして宣言されることもなくなり、完全に実体が１つであることが保証される
　
　シングルトンクラスは別名「お行儀のよいグローバル変数」
　
②Stateパターン
　クラスそのものを”差し替え可能な「状態」”として扱い
　状態から状態へ変化できるようにするパターン
　状態から状態への遷移条件は各状態クラスが知っている
　今の時点ですでに「シーン切り替え」として使っている。

　まず、すべての状態の基底クラスになるクラスを作る
　(今回でいうとSceneクラス)
　あとは、各状態はScnneクラスから派生したクラスとして作る
　(今回でいうとTitleSceneやGameOverSceneなど)
　で、これを所持する側は現在の状態をきにせずただSceneとして扱う
　所有者はただ状態を持って毎回Update関数などを実行するだけ
　
　→状態それぞれが遷移条件や次の状態を知っているため、
　　管理者側が管理する必要がない(管理者側のコードがすっきりする)　
　
　Stateパターンは「状態遷移」を行うために非常に便利なパターン
　状態遷移の方法はStateパターンだけではない
　「実行する内容」を変更できれば「メンバ関数ポインタ」を
　使っても同じようなことができる

関数ポインタとは…
　関数も変数と同じようにアドレスがある
　void Func();
　というのがあって、
　Funcという名前は、この関数があるアドレスに対応している
　実は関数呼び出しというのは、関数があるアドレスにジャンプさせているということ
　実際にはジャンプのときに「戻ってくるべきアドレス」を伝えている(乗っけている)
　これがないと関数実行後にどこに戻っていいかわからなくなるから
　で、この「戻る場所を乗っけてる」のがちょっと曲者

　つまり戻る場所をスタックに乗っけているため、呼び出すたびにスタックをちょっとづつ消費する
　void Function(){
　　function();
　}
　というような「再帰関数」を作ると、コールのたびにちょっとづつスタックを消費してしまう
　なので、再帰関数を作るときは気を付けないと「スタックオーバーフロー」を起こす
　それはともかく、関数というのはアドレスを持っていて、その関数を変数に入れることもできる
　ただし、その時の変数は宣言がちょっとややこしい

　引数なし、戻り値なしの場合は
　void (*f)();
　のように宣言する
　f = Function;
　などのように、関数のアドレスを入れることができる
　これは何が便利なのかというと
　f();
　で関数呼び出しができるが、このときに実行される関数を切り替えることができる

　f = Function;
　f();//Functionが呼ばれる
　f = Function2;
　f();//Function2が呼ばれる

　なので、関数を配列に入れることも可能。
　例えば、ランダムで実行関数を変えたいときは
　void(*f)()[] = {};
　f[rand()%n]();
　のような使い方をする
　
　ここまでは、普通の関数ポインタ
「メンバ関数ポインタ」はさらにもうちょっとややこしい
メンバ関数の場合は、関数のアドレスがオブジェクトの実体から見たアドレスだから、
必ず「誰の持ち物か」を明示しないと使えない

たとえば、クラスMonsterの引数なし戻り値なし関数ポインタを宣言するときは
class Monster{
	void (Monster::*func_)();
};
などと書かなきゃいけない
戻り値(クラス名::*メンバ関数ポインタ名)(引数);

しかも、ポインタへのアドレスの代入もちょっめんどくさい
まず、だれの持つ関数なのかを明記する必要があるため
右辺値はクラス名::関数名で、代入する。ところが、
 func_ = Monster::FadeUpdate;
ではうまくいかない。なぜか
 func_ = &Monster::FadeUpdate;
でないとうまくいかない。
Monster::FadeUpdateだけだとコンパイル時にはじかれてしまう。どうもメンバ関数ポインタに
入れる際は&をつけないといけない文法っぽい

さらに呼び出しの時もめんどくさい
普通の関数ポインタなら、
func_();
でよかったのですが、ここでも「誰の持ち物なのか」を明示しないといけないため
(this->*func_)();
というような呼び出しになる
なお、->*は一つの演算子である(メンバ関数ポインタ指定演算子)

usingというのは、「型の別名」として使うこともできる
(C言語の時代だと、typedefというのが使われていた)

using 別名 = なんか複雑な型;
のように使う。
using GraphicsTable_t = std::map<std::string,std::vector<iny>>;
こういう長い型に対して、GraphicsTable_tという別名をつけれる

メンバ関数ポインタも型がわかりづらいため

using UpdateFunc_t = 戻り値(クラス名::*)(引数);

のように別名を作る。そうすると、面倒くさいメンバ関数ポインタの宣言が

UpdateFunc_t updateFunc_;

と、普通の変数のように宣言できる

画像の合成には、代表的なものとして
①アルファ合成(0.0≦α≦1.0)
	元の画像*(i - α) + 後の画像 * α
	このようにα値で線形補間する
②乗算合成
	元の画像 * 後の画像
	RGB値を(0～1,0～1,0～1)と考える
	元の画像を(sr,sg,sb)で後の画像を(dr,dg,db)とすると
	画素値は(sr*dr,sg*dg,sb*db)となる
	0~1ということは、乗算すれがするほど
	原則的には暗くなる
	(0.5,0.5,0.5) * (0.5,0.5,0.5) = (0.25,0.25,0.25)
	(1.0,0.0,0.0) * (0.0,1.0,0.0) = (0.0,0.0,0.0)	//赤*緑=黒
	
	DxLibのMULAは、後の画像に対してα合成をしている
	(sr,sg,sb) * ((0,0,0) * α + (1,1,1)(1 - α))
③加算合成
	元画像 + 後の画像
	(sr,sg,sb) + (dr,dg,db) = (sr+dr,sg+dg,sb+db);
	原則的に明るくなる(白に近づく)
	
SetDrawBlendModeについて
	使うと、使った以降のすべての描画命令が影響を受ける
	なので、ブレンドが不要な場合は
	SetDrawBlendMode(DX_BLENDMODE_NOBLEND,0);
	で、「ブレンドしない」に戻しておく。
	
	SetDrawBlendMode(DX_BLENDMODE_ALPHA,0);
	これはそれ以降の描画をvalueとして、α合成する
	つまり、描画の内容が
		RGBではなく、value * RGB + (1 - value) * すでに書かれている画像
		となる。
		結果的に「薄く描画する」のような表現になる
		
	SetDrawBlendMode(DX_BLENDMODE_MUL,0);
	SetDrawBlendMode(DX_BLENDMODE_MULA,0);
	これは既に描画されている内容に、このあとのDrawの画像で
	乗算合成する。
	通常のMULの場合は、普通に乗算なのでα値は関係ない
	MULの後に真っ黒な画像を持ってくるとvalueがどうあれ画面は真っ黒になる
	MULAの場合、乗算する際にα値が考慮されるため
	valueが0.5とかだと、真っ黒な画像でもグレーとして取り扱われる
	
	SetDrawBlendMode(DX_BLENDMODE_ADD,0);
	これはこの後に描画する画像を加算合成する
	基本的には明るくなる。valueはα値が考慮されるため
	value = 0.5とかだと0xffffffでも真っ白ではなく、ちょっと明るいくらいに見える。

生ポインタを使わないようにしよう。。。
	自分でnewとかdeleteとかを書いていると、いずれdelete忘れなど出てくる。
	
	なのでもう、newとかdeleteとかを書かなくてもいい仕組みを紹介
	スマートポインタというもの
	(賢いポインタ)
	三種類あるが最初はひとつ(shared_ptr)だけでおｋ
	①shared_ptr : 誰も監視しなくなったら消滅する
	②weak_ptr : 所有権を持っていないため、
					こいつが見ていてもこいつ以外の参照がすべてなくなれば解放される。
					ただし、「生きているか死んでいるか」の判断ができる
	③unique_ptr : 一つしか存在しないポインタ
	↑基本使わない！！！！！
	
	使い方
	shared_ptr<型名> pointer;
	のように宣言する。アドレスがわかっている場合は
	shared_ptr<型名> ponter(アドレス);
	のように宣言時に入れることもできるし、あとから
	pointer.reset(アドレス)


状態遷移の拡張
　
　
　
　

　
　
　
　
　
　
　
　
　
　
　
　


　
　
　
　　
　　
　　