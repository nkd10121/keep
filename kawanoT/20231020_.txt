ここまでは、普通の関数ポインタ
「メンバ関数ポインタ」はさらにもうちょっとややこしい
メンバ関数の場合は、関数のアドレスがオブジェクトの実体から見たアドレスだから、
必ず「誰の持ち物か」を明示しないと使えない

たとえば、クラスMonsterの引数なし戻り値なし関数ポインタを宣言するときは
class Monster{
	void (Monster::*func_)();
};
などと書かなきゃいけない
戻り値(クラス名::*メンバ関数ポインタ名)(引数);

しかも、ポインタへのアドレスの代入もちょっめんどくさい
まず、だれの持つ関数なのかを明記する必要があるため
右辺値はクラス名::関数名で、代入する。ところが、
 func_ = Monster::FadeUpdate;
ではうまくいかない。なぜか
 func_ = &Monster::FadeUpdate;
でないとうまくいかない。
Monster::FadeUpdateだけだとコンパイル時にはじかれてしまう。どうもメンバ関数ポインタに
入れる際は&をつけないといけない文法っぽい

さらに呼び出しの時もめんどくさい
普通の関数ポインタなら、
func_();
でよかったのですが、ここでも「誰の持ち物なのか」を明示しないといけないため
(this->*func_)();
というような呼び出しになる
なお、->*は一つの演算子である(メンバ関数ポインタ指定演算子)

usingというのは、「型の別名」として使うこともできる
(C言語の時代だと、typedefというのが使われていた)

using 別名 = なんか複雑な型;
のように使う。
using GraphicsTable_t = std::map<std::string,std::vector<iny>>;
こういう長い型に対して、GraphicsTable_tという別名をつけれる

メンバ関数ポインタも型がわかりづらいため

using UpdateFunc_t = 戻り値(クラス名::*)(引数);

のように別名を作る。そうすると、面倒くさいメンバ関数ポインタの宣言が

UpdateFunc_t updateFunc_;

と、普通の変数のように宣言できる

画像の合成には、代表的なものとして
①アルファ合成(0.0≦α≦1.0)
	元の画像*(i - α) + 後の画像 * α
	このようにα値で線形補間する
②乗算合成
	元の画像 * 後の画像
	RGB値を(0～1,0～1,0～1)と考える
	元の画像を(sr,sg,sb)で後の画像を(dr,dg,db)とすると
	画素値は(sr*dr,sg*dg,sb*db)となる
	0~1ということは、乗算すれがするほど
	原則的には暗くなる
	(0.5,0.5,0.5) * (0.5,0.5,0.5) = (0.25,0.25,0.25)
	(1.0,0.0,0.0) * (0.0,1.0,0.0) = (0.0,0.0,0.0)	//赤*緑=黒
	
	DxLibのMULAは、後の画像に対してα合成をしている
	(sr,sg,sb) * ((0,0,0) * α + (1,1,1)(1 - α))
③加算合成
	元画像 + 後の画像
	(sr,sg,sb) + (dr,dg,db) = (sr+dr,sg+dg,sb+db);
	原則的に明るくなる(白に近づく)
	
SetDrawBlendModeについて
	使うと、使った以降のすべての描画命令が影響を受ける
	なので、ブレンドが不要な場合は
	SetDrawBlendMode(DX_BLENDMODE_NOBLEND,0);
	で、「ブレンドしない」に戻しておく。
	
	SetDrawBlendMode(DX_BLENDMODE_ALPHA,0);
	これはそれ以降の描画をvalueとして、α合成する
	つまり、描画の内容が
		RGBではなく、value * RGB + (1 - value) * すでに書かれている画像
		となる。
		結果的に「薄く描画する」のような表現になる
		
	SetDrawBlendMode(DX_BLENDMODE_MUL,0);
	SetDrawBlendMode(DX_BLENDMODE_MULA,0);
	これは既に描画されている内容に、このあとのDrawの画像で
	乗算合成する。
	通常のMULの場合は、普通に乗算なのでα値は関係ない
	MULの後に真っ黒な画像を持ってくるとvalueがどうあれ画面は真っ黒になる
	MULAの場合、乗算する際にα値が考慮されるため
	valueが0.5とかだと、真っ黒な画像でもグレーとして取り扱われる
	
	SetDrawBlendMode(DX_BLENDMODE_ADD,0);
	これはこの後に描画する画像を加算合成する
	基本的には明るくなる。valueはα値が考慮されるため
	value = 0.5とかだと0xffffffでも真っ白ではなく、ちょっと明るいくらいに見える。

生ポインタを使わないようにしよう。。。
	自分でnewとかdeleteとかを書いていると、いずれdelete忘れなど出てくる。
	
	なのでもう、newとかdeleteとかを書かなくてもいい仕組みを紹介
	スマートポインタというもの
	(賢いポインタ)
	三種類あるが最初はひとつ(shared_ptr)だけでおｋ
	①shared_ptr : 誰も監視しなくなったら消滅する
	②weak_ptr : 所有権を持っていないため、
					こいつが見ていてもこいつ以外の参照がすべてなくなれば解放される。
					ただし、「生きているか死んでいるか」の判断ができる
	③unique_ptr : 一つしか存在しないポインタ
	↑基本使わない！！！！！
	
	使い方
	shared_ptr<型名> pointer;
	のように宣言する。アドレスがわかっている場合は
	shared_ptr<型名> ponter(アドレス);
	のように宣言時に入れることもできるし、あとから
	pointer.reset(アドレス)


状態遷移の拡張
	
	

